diff --git a/README.md b/README.md
index fe1e73f..47d4ffd 100644
--- a/README.md
+++ b/README.md
@@ -2,21 +2,25 @@
 
 ## Description
 
-#### In this task we have any subproblems:
+#### In this task we have such subproblems:
 1. Implement algorithm to parse business data from a global business data registry.
 2. Store information to a database (MongoDB).
-3. Find algorithm that generates partially or fully the list of valid companies ID
-
-#### Content of project.
-1. The first project 'opencorporates' contain implementation for parsing business data from data registry and added this information to database _MongoDB_. This parser is asynchronous.
-- This parser parse not all id_numbers because it is need too much time. There are we use list of 51 valid id_numbers for show that parser is work.
-2. The second project 'checker' contain algorithm for checking ID is valid or not.
-3. Some support files such as List_of_national_identifiers, test_task (file with text of task), national_identifiers, generate_id (code for generating id numbers) and other.
+3. Find an algorithm that generates a partial of full list of valid IDs of the companies.
+
+## Content of the project
+1. The first project `opencorporates` contains implementation of the parser of business data from the data registry, which adds this information to the _MongoDB_ database. This parser is asynchronous.
+  - This parser works with only a part of all available IDs, as it takes too much time to parse them all. 51 valid IDs are parsed to show, that the parser works.
+2. The second project `checker` contains algorithm for checking if ID is valid or not.
+3. Some support files:
+  - `List_of_national_identifiers.xlsx`
+  - `test_task.docx` - file with the text of the task
+  - `national_identifiers.txt`
+  - `generate_id.py` - code for generating id numbers
+  - others
 
 ## Structure of Database
 
-This project implement Database with name _database_. 
-- Database consist of 5 collections with some fields:
+This project will create a database with the parsed data. It is called _database_ and consists of 5 collections with such fields:
 ### 1. __company_information__
   - __company_number__
   - native_company_number
@@ -25,7 +29,7 @@ This project implement Database with name _database_.
   - registered_address
   - previous_names
   - directors_officers
-  - - name
+  - name
   - - __link__
   - - position
   - - info
@@ -63,44 +67,42 @@ This project implement Database with name _database_.
   - company_name
   - company_link
 
-These collections can be connected with bold fields.
+These collections can be connected together with the fields, which are marked bold.
 
-This database can have not only German companies and officers, because of in the task says that "Similarly named officers (__information from this section, with link and names of the company form each link__)" . Then when we collect Similarly named officers (who can finds not only in the same country) we parse not only German companies and officers.
+This database may have not only German companies and officers, because the task says: "Similarly named officers (__information from this section, with link and names of the company form each link__)". And similarly named officers may be from countries, other than Germany as well.
 
 ## Structure of company id_number
 
 #### We can divide id_number to five separate parts.
 
-For example use a valid id_number  __F1103R_HRA44021__:
+For example, let's use a valid id_number  __F1103R_HRA44021__:
 
-1. F1103 part is associated with city of registration of this company. It is nationl identifier (XJustiz-ID). See all XJustiz-ID in file __List_of_national_identifiers.xlsx__ and list of these XJustiz-ID also contains in national_identifiers.txt
+1. F1103 part is associated with city of registration of this company. It is nationl identifier (XJustiz-ID). See all XJustiz-ID in file `List_of_national_identifiers.xlsx` and list of these XJustiz-ID can also be found in `national_identifiers.txt`
 2. After this part can be R or V or nothing.
 3. "_"
 4. HRA is a type of registry. There are only 5 types of registers such as HRB, HRA, GnR, PR and VR.
 5. The last number combination (in this example 44021) is an index number. This combination can contain 1 to 6 digits.
-6. After this part also can be combination of 1 or 2 letters or nothing.
+6. This part is followed by a combination of 1 or 2 letters, or nothing.
 
-Remark: Then number of possible combinations is 157 * 3 * 5 * 10^6 * (26^2 +1) ≈ 16^11.
-It is too much for checking.
+Remark: number of possible combinations is 157 * 3 * 5 * 10^6 * (26^2 +1) ≈ 16^11.
+It is too much for checking for now.
 
-Also valid id number can be loks like __P2507_P2511_HRB3455__:
-- In this case one of national identifiers is German and second is identifiers of another country.a rough calculation of the value, number, quantity, or extent of something.
-- Last information has the same structure.
+Another example of valid ID is __P2507_P2511_HRB3455__:
+- In this case one of the national identifiers is Germany and second is and identifier of another country: a rough calculation of the value, number, quantity, or extent of something.
+- Last part has the same structure.
 
-#### Well, after this estimation we have some ways.
+## Generation of company_id number
 
 #### Way 1. Brute force (full solution)
 
 We can check all of combinations and add to separate file only valid id.
 
-We can calculate it in >=2 threads. But it is need too much time.
+We can calculate it in >=2 threads. But it needs too much time.
 
 #### Way 2. Estimate by upper bound (partial solution)
 
-For id_numbers which we already have, we can estimate that special case , kind of F1103R_HRA44021. And F1103R_HRA is a static part , but 44021 is an index number. And if we have valid index number 44021 then there are all combinations F1103R_HRA with 1 to 44020.
+For id_numbers which we already have, we can estimate a special case, such as __F1103R_HRA44021__. __F1103R_HRA__ is a static part, and 44021 is an index number. If we have valid index number 44021, then all combinations with __F1103R_HRA__ and numbers from 1 to 44020 are possible.
 
-Based on 51 id_numbers which we already have we can made an algorithm for calculating another id_numbers by upper bound.
+Based on 51 id_numbers, which we already have, we can make an algorithm for calculating another id_numbers by upper bound.
 
-This method immplements in file __estimate_by_upper_bound.py__ . Output stored in file __estimated_id.txt__
-This file is too much for estimated_id file and this file stored in <https://yadi.sk/d/TE1_JbZA0HLnnA>
-(For current 51 id we get 2,874,119 id, full count of commpanies at the moment of writing this file is 5,357,667. Then we found ≈ 50% of numbers).
\ No newline at end of file
+This method is implemented in file `estimate_by_upper_bound.py`. Output is stored in file `estimated_id.txt`. This file's size appeared to be too much for the Github (around 200 Mb), so it was stored by this [link](https://yadi.sk/d/TE1_JbZA0HLnnA). Given that for current 51 IDs we got 2,874,119 IDs and that full count of companies at the moment of writing this file is 5,357,667, we found ≈ 50% of numbers.
\ No newline at end of file
